{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation Install with pip For pip users pip install limeutils Install with git To follow Install a fork To follow Documentation The documentation can be found in: https://dropkickdev.github.io/limeutils/","title":"Home"},{"location":"#installation","text":"","title":"Installation"},{"location":"#install-with-pip","text":"For pip users pip install limeutils","title":"Install with pip"},{"location":"#install-with-git","text":"To follow","title":"Install with git"},{"location":"#install-a-fork","text":"To follow","title":"Install a fork"},{"location":"#documentation","text":"The documentation can be found in: https://dropkickdev.github.io/limeutils/","title":"Documentation"},{"location":"changelog/","text":"","title":"Changelog"},{"location":"utils/","text":"Utils file","title":"Utilities"},{"location":"utils/#utils-file","text":"","title":"Utils file"},{"location":"redis/api/","text":"Redis The Redis() class uses the official redis python package in its methods. Limeutils acts as a wrapper parsing all data it returns into valid python data types. Quickstart Get yourself up and running from limeutils import redis # Create the redis object r = redis . Redis ( pre = 'FOOBAR' , ver = 'v1' ) # Save a key r . set ( 'samplekey' , 'hello there' ) # Read the key message = r . get ( 'samplekey' ) # Save a hash r . hset ( 'user-123' , 'username' , 'jimisawesome' ) # Read the hash username = r . hget ( 'user-123' , 'username' ) Setup from limeutils import redis # Create the redis object r = redis . Redis () With connection information r = redis . Redis ( host = 'localhost' , port = 2468 , db = 0 ) If you don't include any connection information then the redis defaults will be used. Key Prefixes Limeutils lets you use prefixes for your keys allowing for better key management. r = redis . Redis ( pre = 'FOOBAR' , ver = 'v1' ) pre : Prefix for your project. Defaults to an empty string. ver : Version for your key. Defaults to an empty string. This makes sure you won't overrite any keys from other projects. Info Keys you create are automatically saved in the prefix:version:key format (if you used the arguments pre , ver , or both). Creating a key named user in python is saved as FOOBAR:v1:user in redis. But when you need to use this key in your python code you only type the name user and the r object prepends the prefixes for you. If you don't want to use any prefixing just don't use the pre and ver arguments when creating the object. This would mean your original key of user in pyhon would also be saved as user in redis. Redis API All methods are accessible from an instance of the Redis class. These are all validated using Pydantic models. get(key, default='', pre=None, ver=None) Get the value of a single non-hash key. To set the value of this key use set() . Returns : Union[str, int, float] key : Key name default : Use this value if key doesn't exist pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hget(key, field, default='', pre=None, ver=None) Get a single field from a hash key. To set the value of this field use hset() or hmset() . Returns : Union[str, int, float] key : Key name field : Field name default : Use this value if field doesn't exist pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hmget(key: str, fields=None, pre=None, ver=None) Get multiple fields from a hash key. To set the value of these fields use hset() or hmset() . Returns : dict key : Key name fields : List/Tuple of field names pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hmset(key, mapping, ttl=None, pre=None, ver=None) Add multiple fields to a hash key. If the key doesn't exist it is created. Validation done by the pydantic model Hmset . Returns : int Number of fields set. Updating an existing field counts as 0 not 1. key : Key name mapping : Dict of field-val pairs ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hset(key, field, val='', mapping=None, ttl=None, pre=None, ver=None) Add a single field to a hash key. If the key doesn't exist it is created. Returns : int Number of fields set. Updating an existing field counts as 0 not 1. key : Key name field : Field name val : Key value mapping : Dict of field-val pairs ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. set(key, val='', xx=False, keepttl=False, ttl=None, pre=None, ver=None) Create or update a single non-hash key. To read this key use get() . Returns : int Number of keys created. Updated keys aren't counted. key : Key name val : Key value xx : Set to val only if key already exists keepttl : Retain the time to live associated with the key. ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object.","title":"Redis API"},{"location":"redis/api/#redis","text":"The Redis() class uses the official redis python package in its methods. Limeutils acts as a wrapper parsing all data it returns into valid python data types.","title":"Redis"},{"location":"redis/api/#quickstart","text":"Get yourself up and running from limeutils import redis # Create the redis object r = redis . Redis ( pre = 'FOOBAR' , ver = 'v1' ) # Save a key r . set ( 'samplekey' , 'hello there' ) # Read the key message = r . get ( 'samplekey' ) # Save a hash r . hset ( 'user-123' , 'username' , 'jimisawesome' ) # Read the hash username = r . hget ( 'user-123' , 'username' )","title":"Quickstart"},{"location":"redis/api/#setup","text":"from limeutils import redis # Create the redis object r = redis . Redis () With connection information r = redis . Redis ( host = 'localhost' , port = 2468 , db = 0 ) If you don't include any connection information then the redis defaults will be used.","title":"Setup"},{"location":"redis/api/#key-prefixes","text":"Limeutils lets you use prefixes for your keys allowing for better key management. r = redis . Redis ( pre = 'FOOBAR' , ver = 'v1' ) pre : Prefix for your project. Defaults to an empty string. ver : Version for your key. Defaults to an empty string. This makes sure you won't overrite any keys from other projects. Info Keys you create are automatically saved in the prefix:version:key format (if you used the arguments pre , ver , or both). Creating a key named user in python is saved as FOOBAR:v1:user in redis. But when you need to use this key in your python code you only type the name user and the r object prepends the prefixes for you. If you don't want to use any prefixing just don't use the pre and ver arguments when creating the object. This would mean your original key of user in pyhon would also be saved as user in redis.","title":"Key Prefixes"},{"location":"redis/api/#redis-api","text":"All methods are accessible from an instance of the Redis class. These are all validated using Pydantic models. get(key, default='', pre=None, ver=None) Get the value of a single non-hash key. To set the value of this key use set() . Returns : Union[str, int, float] key : Key name default : Use this value if key doesn't exist pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hget(key, field, default='', pre=None, ver=None) Get a single field from a hash key. To set the value of this field use hset() or hmset() . Returns : Union[str, int, float] key : Key name field : Field name default : Use this value if field doesn't exist pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hmget(key: str, fields=None, pre=None, ver=None) Get multiple fields from a hash key. To set the value of these fields use hset() or hmset() . Returns : dict key : Key name fields : List/Tuple of field names pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hmset(key, mapping, ttl=None, pre=None, ver=None) Add multiple fields to a hash key. If the key doesn't exist it is created. Validation done by the pydantic model Hmset . Returns : int Number of fields set. Updating an existing field counts as 0 not 1. key : Key name mapping : Dict of field-val pairs ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hset(key, field, val='', mapping=None, ttl=None, pre=None, ver=None) Add a single field to a hash key. If the key doesn't exist it is created. Returns : int Number of fields set. Updating an existing field counts as 0 not 1. key : Key name field : Field name val : Key value mapping : Dict of field-val pairs ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. set(key, val='', xx=False, keepttl=False, ttl=None, pre=None, ver=None) Create or update a single non-hash key. To read this key use get() . Returns : int Number of keys created. Updated keys aren't counted. key : Key name val : Key value xx : Set to val only if key already exists keepttl : Retain the time to live associated with the key. ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object.","title":"Redis API"},{"location":"redis/models/","text":"Pydantic Models Below are some custom data types used to make the code shorter from typing import Union # Custom data types LT = Union [ list , tuple ] V = Union [ str , int , float , bytes ] The LT and V data types are used throughout this package. Validators nonone def nonone ( val ): \"\"\"Validator: Convert None to empty string.\"\"\" if val is None : return '' return val nonone_mapping def nonone_mapping ( val ): \"\"\"Validator: Convert None to empty string.\"\"\" if val is None or not val : return None else : for k , v in val . items (): val [ k ] = '' if v is None else v return val Models StarterModel class StarterModel ( BaseModel ): key : V pre : Optional [ V ] = '' ver : Optional [ V ] = '' ttl : Optional [ int ] = Field ( 0 , ge = 0 ) Get class Get ( StarterModel ): default : Optional [ Any ] = '' Hget class Hget ( StarterModel ): default : Optional [ Any ] = '' Hmget class Hmget ( StarterModel ): fields_ : Optional [ LT ] = None Hmset class Hmset ( StarterModel ): mapping : Optional [ dict ] = None _clean_mapping = validator ( 'mapping' , allow_reuse = True )( nonone_mapping ) Hset class Hset ( StarterModel ): field : str val : Optional [ V ] mapping : Optional [ dict ] = None _clean_val = validator ( 'val' , allow_reuse = True )( nonone ) _clean_mapping = validator ( 'mapping' , allow_reuse = True )( nonone_mapping ) Set class Set ( StarterModel ): val : Optional [ V ] = '' xx : bool = False keepttl : bool = False _clean_val = validator ( 'val' , allow_reuse = True )( nonone ) @validator ( 'xx' , 'keepttl' ) def boolonly ( cls , val ): return bool ( val )","title":"Models"},{"location":"redis/models/#pydantic-models","text":"Below are some custom data types used to make the code shorter from typing import Union # Custom data types LT = Union [ list , tuple ] V = Union [ str , int , float , bytes ] The LT and V data types are used throughout this package.","title":"Pydantic Models"},{"location":"redis/models/#validators","text":"nonone def nonone ( val ): \"\"\"Validator: Convert None to empty string.\"\"\" if val is None : return '' return val nonone_mapping def nonone_mapping ( val ): \"\"\"Validator: Convert None to empty string.\"\"\" if val is None or not val : return None else : for k , v in val . items (): val [ k ] = '' if v is None else v return val","title":"Validators"},{"location":"redis/models/#models","text":"StarterModel class StarterModel ( BaseModel ): key : V pre : Optional [ V ] = '' ver : Optional [ V ] = '' ttl : Optional [ int ] = Field ( 0 , ge = 0 ) Get class Get ( StarterModel ): default : Optional [ Any ] = '' Hget class Hget ( StarterModel ): default : Optional [ Any ] = '' Hmget class Hmget ( StarterModel ): fields_ : Optional [ LT ] = None Hmset class Hmset ( StarterModel ): mapping : Optional [ dict ] = None _clean_mapping = validator ( 'mapping' , allow_reuse = True )( nonone_mapping ) Hset class Hset ( StarterModel ): field : str val : Optional [ V ] mapping : Optional [ dict ] = None _clean_val = validator ( 'val' , allow_reuse = True )( nonone ) _clean_mapping = validator ( 'mapping' , allow_reuse = True )( nonone_mapping ) Set class Set ( StarterModel ): val : Optional [ V ] = '' xx : bool = False keepttl : bool = False _clean_val = validator ( 'val' , allow_reuse = True )( nonone ) @validator ( 'xx' , 'keepttl' ) def boolonly ( cls , val ): return bool ( val )","title":"Models"}]}