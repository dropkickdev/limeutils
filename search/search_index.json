{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Limeutils Documentation You can use the editor on GitHub to maintain and preview the content for your website in Markdown files. Whenever you commit to this repository, GitHub Pages will run Jekyll to rebuild the pages in your site, from the content in your Markdown files. Markdown Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for Syntax highlighted code block # Header 1 ## Header 2 ### Header 3 - Bulleted - List 1. Numbered 2. List **Bold** and _Italic_ and `Code` text [Link](url) and ![Image](src) For more details see GitHub Flavored Markdown . Jekyll Themes Your Pages site will use the layout and styles from the Jekyll theme you have selected in your repository settings . The name of this theme is saved in the Jekyll _config.yml configuration file. Support or Contact Having trouble with Pages? Check out our documentation or contact support and we\u2019ll help you sort it out.","title":"Home"},{"location":"#limeutils-documentation","text":"You can use the editor on GitHub to maintain and preview the content for your website in Markdown files. Whenever you commit to this repository, GitHub Pages will run Jekyll to rebuild the pages in your site, from the content in your Markdown files.","title":"Limeutils Documentation"},{"location":"#markdown","text":"Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for Syntax highlighted code block # Header 1 ## Header 2 ### Header 3 - Bulleted - List 1. Numbered 2. List **Bold** and _Italic_ and `Code` text [Link](url) and ![Image](src) For more details see GitHub Flavored Markdown .","title":"Markdown"},{"location":"#jekyll-themes","text":"Your Pages site will use the layout and styles from the Jekyll theme you have selected in your repository settings . The name of this theme is saved in the Jekyll _config.yml configuration file.","title":"Jekyll Themes"},{"location":"#support-or-contact","text":"Having trouble with Pages? Check out our documentation or contact support and we\u2019ll help you sort it out.","title":"Support or Contact"},{"location":"redis/","text":"Redis Setup The Redis class uses the official redis package to implement its methods. This class acts as a wrapper for it silently parsing all data coming from your redis database into python data types. from limeutils import redis # Create the redis object r = redis.Redis(pre='FOOBAR', ver='v1') pre : Prefix for your project. Defaults to an empty string. ver : Version for your key. Defaults to an empty string. You can add details about your connection in Redis() . In this case only the default settings are being used. Adding redis connection info: ```python from limeutils import redis r = redis.Redis(host='localhost', port=2468, db=0, pre='FOOBAR', ver='v1') #### Key prefixing It's recommended to use key prefixing in redis so including the `pre` and `ver` attributes does this for you. For example, the key `user-123` is saved as **FOOBAR:v1:user-123** but in your code you just type in `user-123` and not the prefixed version. If you don't want to add any prefixing to your keys then just don't add them when instantiating your object: `r = redis.Redis()`. ### Quickstart ```python from limeutils import redis # Create the redis object r = redis.Redis(pre='FOOBAR', ver='v1') # Save a key r.set('samplekey', 'hello there') # Read the key message = r.get('samplekey') # Save a hash r.hset('user-123', 'username', 'jimisthebomb') # Read the hash username = r.hget('user-123', 'username') Methods All methods are accessible from an instance of the Redis class. All methods are validated using the pydantic package. Below are some custom data types used to make the code shorter. ```python from typing import Union Custom data types LT = Union[list, tuple] V = Union[str, int, float, bytes] `` The LT and V` data types are used throughout this package. get() Something hget() Something hmget() Something hmset() Something hset() Something set(key: str, val: V, xx: bool = False, keepttl: bool = False, ttl=None, pre=None, ver=None ) {:.python} key : Key name val : Key value xx : Set to val only if key already exists keepttl : Retain the time to live associated with the key. ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the pre set in Redis() ver : Custom version. Overrides the ver set in Redis() hget()","title":"Redis"},{"location":"redis/#redis","text":"","title":"Redis"},{"location":"redis/#setup","text":"The Redis class uses the official redis package to implement its methods. This class acts as a wrapper for it silently parsing all data coming from your redis database into python data types. from limeutils import redis # Create the redis object r = redis.Redis(pre='FOOBAR', ver='v1') pre : Prefix for your project. Defaults to an empty string. ver : Version for your key. Defaults to an empty string. You can add details about your connection in Redis() . In this case only the default settings are being used. Adding redis connection info: ```python from limeutils import redis r = redis.Redis(host='localhost', port=2468, db=0, pre='FOOBAR', ver='v1') #### Key prefixing It's recommended to use key prefixing in redis so including the `pre` and `ver` attributes does this for you. For example, the key `user-123` is saved as **FOOBAR:v1:user-123** but in your code you just type in `user-123` and not the prefixed version. If you don't want to add any prefixing to your keys then just don't add them when instantiating your object: `r = redis.Redis()`. ### Quickstart ```python from limeutils import redis # Create the redis object r = redis.Redis(pre='FOOBAR', ver='v1') # Save a key r.set('samplekey', 'hello there') # Read the key message = r.get('samplekey') # Save a hash r.hset('user-123', 'username', 'jimisthebomb') # Read the hash username = r.hget('user-123', 'username')","title":"Setup"},{"location":"redis/#methods","text":"All methods are accessible from an instance of the Redis class. All methods are validated using the pydantic package. Below are some custom data types used to make the code shorter. ```python from typing import Union","title":"Methods"},{"location":"redis/#custom-data-types","text":"LT = Union[list, tuple] V = Union[str, int, float, bytes] `` The LT and V` data types are used throughout this package.","title":"Custom data types"},{"location":"redis/#get","text":"Something","title":"get()"},{"location":"redis/#hget","text":"Something","title":"hget()"},{"location":"redis/#hmget","text":"Something","title":"hmget()"},{"location":"redis/#hmset","text":"Something","title":"hmset()"},{"location":"redis/#hset","text":"Something set(key: str, val: V, xx: bool = False, keepttl: bool = False, ttl=None, pre=None, ver=None ) {:.python} key : Key name val : Key value xx : Set to val only if key already exists keepttl : Retain the time to live associated with the key. ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the pre set in Redis() ver : Custom version. Overrides the ver set in Redis()","title":"hset()"},{"location":"redis/#hget_1","text":"","title":"hget()"},{"location":"setup/","text":"Setting things up","title":"Setting things up"},{"location":"setup/#setting-things-up","text":"","title":"Setting things up"}]}