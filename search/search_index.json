{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Limeutils is a small collection of classes and methds for dealing with Redis data (which comes in bytes and) and a few other helpful functions. Check out the documentation for information . More classes to be added. This package uses Pydantic models to validate its data. Installation Install with pip This is the recommended way to install Limeutils. pip install limeutils Install with repo pip install git+https://github.com/dropkickdev/limeutils.git@develop#egg=limeutils Install with git clone Simply install from the root folder # This can also be a fork git clone https : // github . com / dropkickdev / limeutils . git cd limeutils pip install .","title":"Home"},{"location":"#overview","text":"Limeutils is a small collection of classes and methds for dealing with Redis data (which comes in bytes and) and a few other helpful functions. Check out the documentation for information . More classes to be added. This package uses Pydantic models to validate its data.","title":"Overview"},{"location":"#installation","text":"","title":"Installation"},{"location":"#install-with-pip","text":"This is the recommended way to install Limeutils. pip install limeutils","title":"Install with pip"},{"location":"#install-with-repo","text":"pip install git+https://github.com/dropkickdev/limeutils.git@develop#egg=limeutils","title":"Install with repo"},{"location":"#install-with-git-clone","text":"Simply install from the root folder # This can also be a fork git clone https : // github . com / dropkickdev / limeutils . git cd limeutils pip install .","title":"Install with git clone"},{"location":"changelog/","text":"","title":"Changelog"},{"location":"utils/","text":"Utilities Utilities API isfloat(val) Checks if the contents of a string is a float. Returns : bool val : String to check if it contains a float byte_conv(val) Converts bytes to a python string. This string could later be parsed into the correct python data type using parse_str() . Used mostly with Redis return values which always return in bytes. Returns : str val : Bytes value to convert parse_str(string) Converts a string to either an int, float, or str depending on its value. Does not support pickled values as you'll have to convert those separately. Works well with byte_conv() . Returns : String to convert string : int , float , or str split_fullname(fullname, default='', prefix=None, suffix=None) Splits a fullname into their respective first_name and last_name fields. If only one name is given, that becomes the first_name Returns : tuple containing the firstname and the lastname fullname : The name to split default : The value if only one name is given prefix : Custom prefixes to append to the default list suffix : Custom suffixes to append to the default list fullname = 'Eliza Maria Erica dona Aurora Phd Md' firstname , lastname = split_fullname ( fullname ) print ( firstname ) # Eliza Maria Erica print ( lastname ) # dona Aurora Phd Md Database API model_str(instance, attr) The attribute to display for an object's __str__ . If the attribute doesn't exist then an alternative will be displayed. Commonly used for ORMs but can be applied anywhere with classes. Returns : String name instance : Object of the class attr : Attribute of that object you want to use for its __str__ modstr(instance, attr) Alias for model_str(). classgrabber(dotpath) Import a class from a dot path string. Returns : The class itself which is found at the end of the dot path. Example: # Import the Settings class from a string Settings = classgrabber ( 'app.folder.file.Settings' ) # Settings class now ready for use myobj = Settings ()","title":"Utilities"},{"location":"utils/#utilities","text":"","title":"Utilities"},{"location":"utils/#utilities-api","text":"isfloat(val) Checks if the contents of a string is a float. Returns : bool val : String to check if it contains a float byte_conv(val) Converts bytes to a python string. This string could later be parsed into the correct python data type using parse_str() . Used mostly with Redis return values which always return in bytes. Returns : str val : Bytes value to convert parse_str(string) Converts a string to either an int, float, or str depending on its value. Does not support pickled values as you'll have to convert those separately. Works well with byte_conv() . Returns : String to convert string : int , float , or str split_fullname(fullname, default='', prefix=None, suffix=None) Splits a fullname into their respective first_name and last_name fields. If only one name is given, that becomes the first_name Returns : tuple containing the firstname and the lastname fullname : The name to split default : The value if only one name is given prefix : Custom prefixes to append to the default list suffix : Custom suffixes to append to the default list fullname = 'Eliza Maria Erica dona Aurora Phd Md' firstname , lastname = split_fullname ( fullname ) print ( firstname ) # Eliza Maria Erica print ( lastname ) # dona Aurora Phd Md","title":"Utilities API"},{"location":"utils/#database-api","text":"model_str(instance, attr) The attribute to display for an object's __str__ . If the attribute doesn't exist then an alternative will be displayed. Commonly used for ORMs but can be applied anywhere with classes. Returns : String name instance : Object of the class attr : Attribute of that object you want to use for its __str__ modstr(instance, attr) Alias for model_str(). classgrabber(dotpath) Import a class from a dot path string. Returns : The class itself which is found at the end of the dot path. Example: # Import the Settings class from a string Settings = classgrabber ( 'app.folder.file.Settings' ) # Settings class now ready for use myobj = Settings ()","title":"Database API"},{"location":"redis/api/","text":"Redis Utilities The Redis() class uses the official redis python package in its methods. Limeutils acts as a wrapper parsing all data it returns into valid python data types. Quickstart Get yourself up and running from limeutils import redis # Create the redis object r = redis . Redis ( pre = 'FOOBAR' , ver = 'v1' ) # Save a key r . set ( 'samplekey' , 'hello there' ) # Read the key message = r . get ( 'samplekey' ) # Save a hash r . hset ( 'user-123' , 'username' , 'jimisawesome' ) # Read the hash username = r . hget ( 'user-123' , 'username' ) Example from limeutils import redis # Create the redis object r = redis . Redis () With connection information from limeutils import redis # Create the redis object r = redis . Redis ( host = 'localhost' , port = 2468 , db = 0 ) If you don't include any connection information then the redis defaults will be used. Key Prefixes Limeutils lets you use prefixes for your keys allowing for better key management. Just add it when you create your object. r = redis . Redis ( pre = 'FOOBAR' , ver = 'v1' ) pre : Prefix for your project. Defaults to an empty string. ver : Version for your key. Defaults to an empty string. This makes sure you won't overrite any keys from other projects. Info Keys are saved as prefix:version:key in redis (if you used the arguments pre , ver , or both). Creating a key named user in python is saved as FOOBAR:v1:user in redis. But when you need to use this key in python you only type the name user and the r object prepends the prefixes for you. Redis API All methods are accessible from an instance of the Redis class. These are all validated using Pydantic models. get(key, default='', pre=None, ver=None) Get the value of a single non-hash key. To set the value of this key use set() . Returns : Union[str, int, float] key : Key name default : Use this value if key doesn't exist pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hget(key, field, default='', pre=None, ver=None) Get a single field from a hash key. To set the value of this field use hset() or hmset() . Returns : Union[str, int, float] key : Key name field : Field name default : Use this value if field doesn't exist pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hmget(key: str, fields=None, pre=None, ver=None) Get multiple fields from a hash key. To set the value of these fields use hset() or `hmset() . Returns : dict key : Key name fields : List/Tuple of field names pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hmset(key, mapping, ttl=None, pre=None, ver=None) Add multiple fields to a hash key. If the key doesn't exist it is created. Validation done by the pydantic model Hmset . Returns : int Number of fields set. Updating an existing field counts as 0 not 1. key : Key name mapping : Dict of field-val pairs ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hset(key, field, val='', mapping=None, ttl=None, pre=None, ver=None) Add a single field to a hash key. If the key doesn't exist it is created. Returns : int Number of fields set. Updating an existing field counts as 0 not 1. key : Key name field : Field name val : Key value mapping : Dict of field-val pairs ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. set(key, val='', xx=False, keepttl=False, ttl=None, pre=None, ver=None) Create or update a single non-hash key. To read this key use get() . Returns : int Number of keys created. Updated keys aren't counted. key : Key name val : Key value xx : Set to val only if key already exists keepttl : Retain the time to live associated with the key. ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object.","title":"Redis API"},{"location":"redis/api/#redis-utilities","text":"The Redis() class uses the official redis python package in its methods. Limeutils acts as a wrapper parsing all data it returns into valid python data types.","title":"Redis Utilities"},{"location":"redis/api/#quickstart","text":"Get yourself up and running from limeutils import redis # Create the redis object r = redis . Redis ( pre = 'FOOBAR' , ver = 'v1' ) # Save a key r . set ( 'samplekey' , 'hello there' ) # Read the key message = r . get ( 'samplekey' ) # Save a hash r . hset ( 'user-123' , 'username' , 'jimisawesome' ) # Read the hash username = r . hget ( 'user-123' , 'username' )","title":"Quickstart"},{"location":"redis/api/#example","text":"from limeutils import redis # Create the redis object r = redis . Redis () With connection information from limeutils import redis # Create the redis object r = redis . Redis ( host = 'localhost' , port = 2468 , db = 0 ) If you don't include any connection information then the redis defaults will be used.","title":"Example"},{"location":"redis/api/#key-prefixes","text":"Limeutils lets you use prefixes for your keys allowing for better key management. Just add it when you create your object. r = redis . Redis ( pre = 'FOOBAR' , ver = 'v1' ) pre : Prefix for your project. Defaults to an empty string. ver : Version for your key. Defaults to an empty string. This makes sure you won't overrite any keys from other projects. Info Keys are saved as prefix:version:key in redis (if you used the arguments pre , ver , or both). Creating a key named user in python is saved as FOOBAR:v1:user in redis. But when you need to use this key in python you only type the name user and the r object prepends the prefixes for you.","title":"Key Prefixes"},{"location":"redis/api/#redis-api","text":"All methods are accessible from an instance of the Redis class. These are all validated using Pydantic models. get(key, default='', pre=None, ver=None) Get the value of a single non-hash key. To set the value of this key use set() . Returns : Union[str, int, float] key : Key name default : Use this value if key doesn't exist pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hget(key, field, default='', pre=None, ver=None) Get a single field from a hash key. To set the value of this field use hset() or hmset() . Returns : Union[str, int, float] key : Key name field : Field name default : Use this value if field doesn't exist pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hmget(key: str, fields=None, pre=None, ver=None) Get multiple fields from a hash key. To set the value of these fields use hset() or `hmset() . Returns : dict key : Key name fields : List/Tuple of field names pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hmset(key, mapping, ttl=None, pre=None, ver=None) Add multiple fields to a hash key. If the key doesn't exist it is created. Validation done by the pydantic model Hmset . Returns : int Number of fields set. Updating an existing field counts as 0 not 1. key : Key name mapping : Dict of field-val pairs ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. hset(key, field, val='', mapping=None, ttl=None, pre=None, ver=None) Add a single field to a hash key. If the key doesn't exist it is created. Returns : int Number of fields set. Updating an existing field counts as 0 not 1. key : Key name field : Field name val : Key value mapping : Dict of field-val pairs ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object. set(key, val='', xx=False, keepttl=False, ttl=None, pre=None, ver=None) Create or update a single non-hash key. To read this key use get() . Returns : int Number of keys created. Updated keys aren't counted. key : Key name val : Key value xx : Set to val only if key already exists keepttl : Retain the time to live associated with the key. ttl : TTL for this key. Can be in int seconds or a timedelta object. pre : Custom prefix. Overrides the prefix set when you created the object. ver : Custom version. Overrides the version set when you created the object.","title":"Redis API"},{"location":"redis/models/","text":"Pydantic Models Below are some custom data types used to make the code shorter from typing import Union # Custom data types LT = Union [ list , tuple ] V = Union [ str , int , float , bytes ] The LT and V data types are used throughout this package. Validators These work behind the scenes for the value of each key/field and are here for reference purposes. listmaker(val) Converts a str to a list with one item. nonone(val) Converts a None to empty string. nonone_mapping(val) Converts a None to empty string for dict . Models Pydantic models which validate the data. StarterModel Almost all other models have these fields so they were separated. class StarterModel ( BaseModel ): key : V pre : Optional [ V ] = '' ver : Optional [ V ] = '' ttl : Optional [ int ] = Field ( 0 , ge = 0 ) Get class Get ( StarterModel ): default : Optional [ Any ] = '' Hget class Hget ( StarterModel ): default : Optional [ Any ] = '' Hmget class Hmget ( StarterModel ): fields_ : Optional [ LT ] = None Hmset class Hmset ( StarterModel ): mapping : Optional [ dict ] = None _clean_mapping = validator ( 'mapping' , allow_reuse = True )( nonone_mapping ) Hset class Hset ( StarterModel ): field : str val : Optional [ V ] mapping : Optional [ dict ] = None _clean_val = validator ( 'val' , allow_reuse = True )( nonone ) _clean_mapping = validator ( 'mapping' , allow_reuse = True )( nonone_mapping ) Set class Set ( StarterModel ): val : Optional [ V ] = '' xx : bool = False keepttl : bool = False _clean_val = validator ( 'val' , allow_reuse = True )( nonone ) @validator ( 'xx' , 'keepttl' ) def boolonly ( cls , val ): return bool ( val )","title":"Models"},{"location":"redis/models/#pydantic-models","text":"Below are some custom data types used to make the code shorter from typing import Union # Custom data types LT = Union [ list , tuple ] V = Union [ str , int , float , bytes ] The LT and V data types are used throughout this package.","title":"Pydantic Models"},{"location":"redis/models/#validators","text":"These work behind the scenes for the value of each key/field and are here for reference purposes. listmaker(val) Converts a str to a list with one item. nonone(val) Converts a None to empty string. nonone_mapping(val) Converts a None to empty string for dict .","title":"Validators"},{"location":"redis/models/#models","text":"Pydantic models which validate the data. StarterModel Almost all other models have these fields so they were separated. class StarterModel ( BaseModel ): key : V pre : Optional [ V ] = '' ver : Optional [ V ] = '' ttl : Optional [ int ] = Field ( 0 , ge = 0 ) Get class Get ( StarterModel ): default : Optional [ Any ] = '' Hget class Hget ( StarterModel ): default : Optional [ Any ] = '' Hmget class Hmget ( StarterModel ): fields_ : Optional [ LT ] = None Hmset class Hmset ( StarterModel ): mapping : Optional [ dict ] = None _clean_mapping = validator ( 'mapping' , allow_reuse = True )( nonone_mapping ) Hset class Hset ( StarterModel ): field : str val : Optional [ V ] mapping : Optional [ dict ] = None _clean_val = validator ( 'val' , allow_reuse = True )( nonone ) _clean_mapping = validator ( 'mapping' , allow_reuse = True )( nonone_mapping ) Set class Set ( StarterModel ): val : Optional [ V ] = '' xx : bool = False keepttl : bool = False _clean_val = validator ( 'val' , allow_reuse = True )( nonone ) @validator ( 'xx' , 'keepttl' ) def boolonly ( cls , val ): return bool ( val )","title":"Models"}]}